/*
    A slave is a single CPU utilizing server. It is asynchronous but not threaded.
    It manages zero or more zones. For better utilization of multiple processors
    one should use multiple slaves.
*/

var dbjuggle = require('./dbjuggle.js');
var ws = require('ws');
var zonehost = require('./zonehost.js');

var slave = function (cfg) {
	var state = {
		cfg:        cfg,
		running:    true,
        zhosts:     {},
	};

    this.state = state;

	state.uid = 100;
	state.clients = {};

	dbjuggle.opendatabase(state.cfg.db, function (err, db) {
        /*
            We share the same database connection with our zone hosts, but
            this could be changed in the future if needed.
        */
        state.db = db;


		/*
			Manually increment reference count so the DB connection is not
			released after this function returns. If Javascript supported
			or I can implemented a better automatic resource release then
			I would use it.
		*/
		db.acquire();

		/*
			Let everyone know that we are online.
		*/
		var t = db.transaction();
		t.add(' \
			INSERT INTO slaves (sid, address, lastalive, up, locked, workload) VALUES (?, ?, ?, 1, 0, 0) \
			ON DUPLICATE KEY UPDATE sid = ?, address = ?, lastalive = ?, up = 1, locked = 0, workload = 0 \
		',
			[
				state.cfg.sid, state.cfg.address, new Date().getTime(),
				state.cfg.sid, state.cfg.address, new Date().getTime()
			]
		);

		t.execute(function (t) {
			console.log('Updated database with our information.');
			t.commit();
		});

		var WebSocketServer = ws.Server;
		var wss = new WebSocketServer({
			port: state.cfg.port
		});

		wss.on('connection', function (ws) {
      console.log('[slave] connection request');
			ws.uid = state.uid++;
			ws.isAvatar = false;
			state.clients[ws.uid] = ws;

            ws.sendjson = function (msg) {
                ws.send(JSON.stringify(msg));
            }

			ws.on('message', function (msg, flags) {
				/*
					This will be recieving data directly
					from untrusted clients. To prevent
					DOS attack consider quick scan of start
					of JSON packet to determine type and apply
					appropriate size limitations.
				*/
				try {
					msg = JSON.parse(msg);
                    msg.$sendjsonreply = function (msg) {
                        /*
                            The special field `__rid` links the
                            reply to the request. The remote end
                            if it supports it can handle it. This
                            allows the remote end to be asynchronous
                            in receiving results, and cuts down on
                            the code I have to write to reply to
                            a specific message.
                        */
                        msg.__rid = this.__rid;
                        ws.sendjson(msg);
                    };
				} catch (err) {
					/*
						This keeps a client from crashing us
						with a bad JSON packet.
					*/
					throw err;
				}

				if (msg.tozone) {
					state.zhosts[zid].onMessage(msg);
				}

				switch (msg.subject) {
					case 'login':
                        /*
                            TODO: add need to exchange hash generated by index
                                  sever and shared with this slave just for this
                                  (uid, mid, zid) in order to ensure security
                        */
						var uid = msg.uid;
                        var mid = msg.mid;
                        var zid = msg.zid;

                        /*
                            Do we have this zone hosted?
                        */

                        if (!state.zhosts[zid]) {
                            return ws.sendjson({
                                subject:     'login-rejected',
                                desc:    'The zone is not hosted on this slave.'
                            });
                        }

                        var mach = state.zhosts[zid].getMachineByID(mid);

                        /*
                            Is this machine hosted in this zone? If so we need
                            to grab a reference to it in memory.
                        */
                        if (!mach) {
                            return ws.sendjson({
                                subject:     'login-rejected',
                                desc:    'The machine does not exist in zone.'
                            });
                        }

						ws.zid = zid;
						ws.isAvatar = true;
						ws.machine = mach;
                        /*
                            Attach ourself to the machine so that we can recieve
                            updates for what happens to it and around it.
                        */
                        mach.attachAvatarSocket(ws);
						break;
					case 'block-read':
						var blocks = msg.blocks;
						ws.machine.blockRead(blocks, function (res) {
							msg.$sendjsonreply({
								subject:   'block-read-result',
								blocks:    res
							});
						});
						break;
					case 'logout':
						break;
                    case 'create-machine-instance':
                        /*
                            This happens when a machine traverses from one
                            zone into another. The machine is saved to the
                            database and setup for migration. Then here we
                            get notified to pull it down into a zone we host.

                            If an avatar was attached it will soon re-attach
                            using a `login` command.
                        */
                        var mid = msg.mid;
                        var zid = msg.zid;
                        if (!state.zhosts[zid]) {
                            return msg.$sendjsonreply({
								subject:        'create-machine-instance-error',
                                success:    false,
                                desc:       'The zone is not hosted on this slave.'
                            });
                        }

                        var mach = state.zhosts[zid].createMachineInstance(mid);

                        if (!mach) {
                            return msg.$sendjsonreply({
                                success:    false,
                                mid:        mid,
                                desc:       'Failed to create an instance of machine.'
                            });
                        }

                        break;
					case 'host-zone-request':
            /*
              We should consider hosting this zone. If we are
              too loaded then we need to reject. If this zone
              is critical to be hosted then support should be
              added to handle that case (forced host).

              TODO: I am just going to host anything request for
                    now.
            */
            var zid = msg.zid;
            var patches = msg.patches;
            state.zhosts[zid] = new zonehost(state, zid, patches, function () {
	  				  msg.$sendjsonreply({
		  				  success:        true
						  });
						});
            break;
				}
			});

			ws.on('close', function () {
				delete state.clients[ws.uid];
			});
		});

		function pause_server() {
			state.running = false;
		}

		function resume_server() {
			state.running = true;
		}
	});
};

module.exports = slave;
